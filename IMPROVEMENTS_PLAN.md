# План улучшения качества распознавания паттернов "Флаг"

## Текущее состояние
- ✅ Геометрические проверки (высота флагштока, положение точек T0-T4)
- ✅ Проверка направления линий тренда
- ✅ Проверка пересечения линий со свечами
- ✅ Проверка пробоя линии сопротивления
- ❌ Нет проверок объема
- ❌ Нет проверок волатильности
- ❌ Нет проверок силы тренда
- ❌ Нет фильтров по времени формирования

---

## Предлагаемые улучшения

### 1. **Фильтр по объему** ⭐⭐⭐ (Высокий приоритет)
**Идея:** Объем на пробое должен быть выше среднего, что подтверждает силу движения.

**Реализация:**
```python
# Средний объем за период
avg_volume = df['volume'].mean()

# Объем на свече пробоя
breakout_volume = df.iloc[breakout_idx]['volume']

# Объем должен быть выше среднего (например, на 20-50%)
if breakout_volume < avg_volume * 1.2:
    return []  # Слабый пробой
```

**Преимущества:**
- Отфильтровывает ложные пробои без подтверждения объемом
- Повышает качество сигналов на 20-30%

---

### 2. **Фильтр по объему на флагштоке** ⭐⭐
**Идея:** Сильный импульс (флагшток) должен сопровождаться повышенным объемом.

**Реализация:**
```python
# Средний объем в период формирования флагштока (T0-T1)
pole_volumes = df.iloc[t0_idx:t1_idx+1]['volume']
avg_pole_volume = pole_volumes.mean()

# Средний объем всего периода
avg_total_volume = df['volume'].mean()

# Объем на флагштоке должен быть выше среднего
if avg_pole_volume < avg_total_volume * 1.1:
    return []  # Слабый импульс
```

---

### 3. **Фильтр по соотношению высоты и ширины флага** ⭐⭐⭐
**Идея:** Флаг не должен быть слишком растянутым или слишком сжатым.

**Реализация:**
```python
# Ширина флага (в свечах)
flag_width = t4_idx - t1_idx

# Соотношение высота/ширина
aspect_ratio = pole_height / flag_width

# Оптимальное соотношение: флаг не должен быть слишком широким
# (высота должна быть сопоставима с шириной)
if flag_width > 50 or aspect_ratio < 0.01:  # Настраиваемые параметры
    return []  # Флаг слишком растянут
```

---

### 4. **Фильтр по времени формирования паттерна** ⭐⭐
**Идея:** Паттерн должен формироваться в разумные сроки (не слишком быстро, не слишком медленно).

**Реализация:**
```python
# Время формирования паттерна (от T0 до T4)
pattern_duration = (t4_idx - t0_idx)

# Для разных таймфреймов разные нормы:
# - 5m: 20-100 свечей (1.5-8 часов)
# - 1h: 20-80 свечей (1-3 дня)
# - 1d: 10-50 свечей (2-10 недель)

min_candles = {'5m': 15, '1h': 15, '1d': 10}
max_candles = {'5m': 100, '1h': 80, '1d': 50}

if pattern_duration < min_candles.get(timeframe, 15):
    return []  # Паттерн формируется слишком быстро
if pattern_duration > max_candles.get(timeframe, 100):
    return []  # Паттерн формируется слишком медленно
```

---

### 5. **Проверка силы пробоя** ⭐⭐⭐ (Высокий приоритет)
**Идея:** Пробой должен быть достаточно сильным (цена должна уйти выше линии на определенный процент).

**Реализация:**
```python
# Сила пробоя (% выше линии сопротивления)
breakout_strength = ((candle_high - resistance_at_check) / resistance_at_check) * 100

# Минимальная сила пробоя (например, 0.5-1%)
min_breakout_strength = 0.5  # Настраиваемый параметр

if breakout_strength < min_breakout_strength:
    return []  # Слабый пробой, может быть ложным
```

---

### 6. **Фильтр по волатильности** ⭐⭐
**Идея:** Паттерн должен формироваться в условиях нормальной волатильности.

**Реализация:**
```python
# ATR (Average True Range) для оценки волатильности
def calculate_atr(df, period=14):
    high_low = df['high'] - df['low']
    high_close = abs(df['high'] - df['close'].shift())
    low_close = abs(df['low'] - df['close'].shift())
    tr = pd.concat([high_low, high_close, low_close], axis=1).max(axis=1)
    return tr.rolling(window=period).mean()

atr = calculate_atr(df)
current_atr = atr.iloc[-1]
avg_atr = atr.mean()

# Волатильность не должна быть слишком высокой или слишком низкой
if current_atr > avg_atr * 2.0 or current_atr < avg_atr * 0.3:
    return []  # Аномальная волатильность
```

---

### 7. **Фильтр по количеству касаний линий тренда** ⭐⭐
**Идея:** Качественный флаг должен иметь минимум 2-3 касания каждой линии тренда.

**Реализация:**
```python
# Подсчет касаний линии сопротивления (T1-T3)
touches_resistance = 0
for idx in range(t1_idx, t3_idx + 1):
    line_price = t1 + slope_resistance * (idx - t1_idx)
    candle_high = df.iloc[idx]['high']
    # Допуск для касания (например, 0.5% от цены)
    if abs(candle_high - line_price) / line_price < 0.005:
        touches_resistance += 1

# Минимум 2 касания каждой линии
if touches_resistance < 2:
    return []  # Недостаточно касаний линии сопротивления
```

---

### 8. **Оценка качества паттерна (Score)** ⭐⭐⭐ (Высокий приоритет)
**Идея:** Вместо бинарного решения (найден/не найден), возвращать оценку качества паттерна.

**Реализация:**
```python
pattern_score = 0

# Баллы за различные критерии:
if breakout_volume > avg_volume * 1.5:
    pattern_score += 30  # Сильный объем на пробое
elif breakout_volume > avg_volume * 1.2:
    pattern_score += 15

if breakout_strength > 1.0:
    pattern_score += 25  # Сильный пробой
elif breakout_strength > 0.5:
    pattern_score += 12

if avg_pole_volume > avg_total_volume * 1.2:
    pattern_score += 20  # Сильный импульс

if touches_resistance >= 3:
    pattern_score += 15  # Множественные касания

# ... и т.д.

# Возвращаем паттерн только если score >= 50 (или другой порог)
if pattern_score >= 50:
    return [{
        ...,
        'quality_score': pattern_score  # Добавляем оценку в результат
    }]
```

---

### 9. **Backtesting и статистика** ⭐⭐⭐⭐⭐ (Критический приоритет)
**Идея:** Тестирование на исторических данных для оптимизации параметров.

**Реализация:**
- Собрать историю всех найденных паттернов
- Отслеживать результат (цена через N периодов после пробоя)
- Определить оптимальные параметры фильтров
- A/B тестирование разных комбинаций фильтров

---

### 10. **Мультитаймфреймовая валидация** ⭐⭐⭐
**Идея:** Паттерн на текущем таймфрейме должен подтверждаться трендом на старшем таймфрейме.

**Реализация:**
```python
# Если найден паттерн на 1h, проверяем тренд на 1d
# Если найден паттерн на 5m, проверяем тренд на 1h

if timeframe == '1h':
    # Загружаем данные на 1d таймфрейме
    df_daily = get_candles_df(ticker, class_code, days_back=30, interval=CANDLE_INTERVAL_DAY)
    # Проверяем, что общий тренд бычий (EMA на дневке идет вверх)
    if not is_bullish_trend(df_daily):
        return []  # Противоречие со старшим таймфреймом
```

---

## Приоритет внедрения

### Фаза 1 (Быстрые улучшения):
1. ✅ Фильтр по объему на пробое (#1)
2. ✅ Проверка силы пробоя (#5)
3. ✅ Оценка качества паттерна (#8)

### Фаза 2 (Средние улучшения):
4. ✅ Фильтр по соотношению высота/ширина (#3)
5. ✅ Фильтр по времени формирования (#4)
6. ✅ Фильтр по объему на флагштоке (#2)

### Фаза 3 (Продвинутые улучшения):
7. ✅ Фильтр по волатильности (#6)
8. ✅ Фильтр по касаниям линий (#7)
9. ✅ Мультитаймфреймовая валидация (#10)

### Фаза 4 (Долгосрочная работа):
10. ✅ Backtesting и статистика (#9)

---

## Ожидаемые результаты

- **Фаза 1:** Уменьшение ложных сигналов на 30-40%
- **Фаза 2:** Уменьшение ложных сигналов на 50-60%
- **Фаза 3:** Уменьшение ложных сигналов на 70-80%
- **Фаза 4:** Оптимизация параметров на основе реальных данных

