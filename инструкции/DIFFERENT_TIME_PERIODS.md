# Проблема: Разные временные промежутки и индексы

## Проблема

**Вы правы!** Если загружать разные временные промежутки, индексы свечей для одного и того же паттерна будут разными.

### Пример:

**Сценарий 1:** Загружено 500 свечей
```
Паттерн находится на свече с индексом 150
```

**Сценарий 2:** Загружено только 100 свечей (период с паттерном)
```
Тот же паттерн, но теперь на свече с индексом 30
```

**Проблема:** Индексы разные (150 vs 30), но это один и тот же паттерн!

---

## Решение: Нормализация координат

**Ключевая идея:** Индекс сохраняется относительно всего DataFrame, но при обучении преобразуется в нормализованные координаты относительно **окна анализа**.

### Как это работает:

#### Шаг 1: Разметка (сохранение)

При разметке сохраняем **абсолютный индекс** относительно загруженного DataFrame:

```python
# Загружено 500 свечей (idx 0-499)
# Паттерн на свече 150
st.session_state.points['T0'] = {
    'idx': 150,  # Абсолютный индекс в загруженном DataFrame
    'price': 292.5
}

# Сохраняется в annotations.csv:
# t0_idx = 150
```

#### Шаг 2: Загрузка для обучения

При загрузке данных для обучения берем **окно** (например, последние 100 свечей):

```python
# Из data_loader_keypoints.py
def _candles_to_image(self, df, window=100):
    # Берем последние window свечей
    if len(df) > window:
        df_plot = df.tail(window).copy()  # Последние 100
        window_start = len(df) - window   # Начало окна
    else:
        df_plot = df.copy()
        window_start = 0
    
    # window_start = 400 (если было 500 свечей, берем 400-499)
```

#### Шаг 3: Преобразование индекса

Абсолютный индекс преобразуется в **относительный индекс окна**, затем в нормализованную координату:

```python
def _load_keypoints(self, row, df, normalization_params):
    # Абсолютный индекс из annotations.csv
    candle_idx = int(row['t0_idx'])  # 150
    
    # Начало окна (последние 100 свечей)
    window_start = normalization_params['window_start']  # 400
    
    # Относительный индекс в окне
    relative_idx = candle_idx - window_start  # 150 - 400 = -250 ❌ ПРОБЛЕМА!
    
    # Нормализованная координата
    x_norm = relative_idx / window_size  # Неправильно, если индекс вне окна!
```

---

## Текущая проблема в коде

**Проблема:** Текущая реализация предполагает, что индекс в annotations.csv соответствует индексу в окне, но на самом деле индекс может быть абсолютным.

### Что происходит сейчас:

1. **Разметка:** Сохраняется абсолютный индекс (150)
2. **Загрузка:** Берется окно (400-499)
3. **Преобразование:** `150 - 400 = -250` → неправильная координата! ❌

---

## Правильное решение

### Вариант 1: Сохранять относительные индексы (рекомендуется)

При разметке сохранять индекс **относительно окна**, а не абсолютный:

```python
# В labeling_dashboard при сохранении
# Убедиться, что окно = весь DataFrame, или сохранять относительный индекс

# Если окно = весь DataFrame (len(df) <= window):
window_start = 0
relative_idx = absolute_idx - window_start  # = absolute_idx

# Если окно < весь DataFrame:
# Нужно сохранять только последние window свечей для обучения
```

**Или:** Всегда сохранять только последние N свечей в CSV, чтобы индекс был относительным.

### Вариант 2: Обрабатывать абсолютные индексы (более гибко)

При загрузке проверять, попадает ли индекс в окно:

```python
def _load_keypoints(self, row, df, normalization_params):
    candle_idx = int(row['t0_idx'])  # Абсолютный индекс
    window_start = normalization_params['window_start']
    window_size = self.window
    
    # Проверяем, попадает ли индекс в окно
    if window_start <= candle_idx < window_start + window_size:
        # Индекс в окне - используем его
        relative_idx = candle_idx - window_start
        x_norm = relative_idx / window_size
    else:
        # Индекс вне окна - пропускаем или используем центр
        x_norm = 0.5  # Центр окна
        # Или можно пропустить этот пример
```

### Вариант 3: Всегда использовать весь DataFrame (проще всего)

При разметке и обучении использовать **весь загруженный DataFrame** как окно:

```python
# В data_loader_keypoints.py
def _candles_to_image(self, df, window=None):
    # Всегда используем весь DataFrame
    df_plot = df.copy()
    window_start = 0
    
    # Ограничиваем только если данных слишком много
    if len(df_plot) > window:
        df_plot = df_plot.tail(window).copy()
        window_start = len(df) - window
```

---

## Рекомендация

**Использовать Вариант 3:** Всегда использовать весь DataFrame при обучении.

**Почему:**
- ✅ Проще - не нужно обрабатывать разные случаи
- ✅ Соответствует разметке - пользователь размечает весь загруженный график
- ✅ Индексы совпадают - индекс в annotations = индекс в DataFrame

**Ограничение:** Если данных очень много (>500 свечей), лучше ограничить окно, но тогда нужно:
1. Либо переразмечать данные с учетом окна
2. Либо использовать Вариант 2 (обработка абсолютных индексов)

---

## Текущее состояние кода

**Проблема:** Код может работать неправильно, если:
- Загружено много свечей (> window)
- Индекс в annotations.csv абсолютный (относительно всего DataFrame)
- Окно берется только последние N свечей

**Решение:** Нужно либо:
1. Всегда использовать весь DataFrame (если len(df) <= window * 2)
2. Либо исправить преобразование индексов (Вариант 2)

---

## Пример правильной работы

### Правильный сценарий:

**Разметка:**
```python
# Загружено 200 свечей (idx 0-199)
# Паттерн на свече 150
# Сохраняется: t0_idx = 150
```

**Обучение:**
```python
# Загружается тот же файл: 200 свечей (idx 0-199)
# Используется весь DataFrame (window=100, но len(df)=200 <= 200)
# window_start = 0 (используем все данные)
# Преобразование: 150 - 0 = 150 → x_norm = 150/200 = 0.75 ✅
```

**Проблемный сценарий:**
```python
# Загружено 500 свечей (idx 0-499)
# Паттерн на свече 150
# Сохраняется: t0_idx = 150
# Но при обучении берется окно 400-499 (window=100)
# Преобразование: 150 - 400 = -250 → ошибка! ❌
```

---

## Вывод

**Проблема реальна!** Индексы будут разными при разных временных промежутках.

**Решения:**
1. ✅ Всегда использовать весь DataFrame при обучении (если возможно)
2. ✅ Обрабатывать абсолютные индексы и проверять попадание в окно
3. ✅ Сохранять только последние N свечей для обучения (чтобы индексы были относительными)

**Текущий код требует доработки** для правильной обработки этого случая.

