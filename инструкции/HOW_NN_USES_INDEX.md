# Как нейросеть использует индекс при работе с реальными графиками?

## Важный момент

**Нейросеть НЕ предсказывает индекс напрямую!**

Вместо этого:
1. **При обучении:** Индекс → нормализованные координаты (0-1)
2. **При предсказании:** Нормализованные координаты (0-1) → обратное преобразование → индекс свечи

---

## Полный процесс

### Этап 1: Обучение (Training)

```
Свечные данные (CSV)
  ↓
Координаты точек:
  T0: idx=150, price=292.5
  T1: idx=161, price=295.8
  ...
  ↓
Преобразование в нормализованные координаты:
  T0: x_norm=0.5, y_norm=0.3  (0-1)
  T1: x_norm=0.61, y_norm=0.8  (0-1)
  ...
  ↓
Изображение (224x224)
  ↓
Нейросеть учится предсказывать:
  Вход: Изображение
  Выход: [x_norm, y_norm] для каждой точки T0-T4
```

**Код в `data_loader_keypoints.py`:**
```python
# Преобразование idx → x_norm
x_norm = (candle_idx - window_start) / window_size  # 0-1
y_norm = (point_price - price_min) / price_range    # 0-1

# Модель учится предсказывать [x_norm, y_norm]
```

---

### Этап 2: Предсказание на новых данных (Inference)

```
Новые свечные данные (реальный график)
  ↓
Изображение (224x224)
  ↓
Нейросеть предсказывает:
  T0: x_norm=0.52, y_norm=0.31
  T1: x_norm=0.63, y_norm=0.82
  ...
  ↓
Обратное преобразование:
  x_norm → candle_idx (индекс свечи)
  y_norm → price (цена)
  ↓
Результат:
  T0: idx=152, price=292.8
  T1: idx=163, price=296.1
  ...
```

**Код в `predict_keypoints.py`:**
```python
# Нейросеть предсказывает нормализованные координаты
class_logits, pred_keypoints = model(image_batch)
# pred_keypoints: [5, 2] - нормализованные координаты (0-1)

# Обратное преобразование: нормализованные → реальные
for i, (x_norm, y_norm) in enumerate(pred_keypoints):
    # X: из нормализованной координаты в индекс свечи
    candle_idx = int(x_norm * len(df_plot))
    candle_idx = max(0, min(len(df_plot) - 1, candle_idx))
    
    # Y: из нормализованной координаты в цену
    price = price_min + y_norm * price_range
    
    # Корректируем индекс относительно исходного DataFrame
    actual_idx = window_start + candle_idx
```

---

## Детальный разбор

### Шаг 1: Обучение (idx → нормализованные координаты)

**Дано:**
- DataFrame с 500 свечами
- Окно: 100 свечей (последние 100)
- Точка T0: idx=450, price=292.5
- window_start = 400 (начало окна)
- price_min = 290.0, price_max = 300.0

**Преобразование:**
```python
# X-координата (позиция в окне)
x_norm = (450 - 400) / 100 = 0.5  # Центр окна

# Y-координата (цена)
y_norm = (292.5 - 290.0) / (300.0 - 290.0) = 0.25

# Модель учится: изображение → [0.5, 0.25]
```

### Шаг 2: Предсказание (нормализованные → idx)

**Дано:**
- Новый график: 500 свечей
- Окно: последние 100 свечей (idx 400-499)
- Нейросеть предсказала: x_norm=0.52, y_norm=0.31
- price_min = 290.0, price_max = 300.0
- window_start = 400

**Обратное преобразование:**
```python
# X: нормализованная координата → индекс в окне
candle_idx_in_window = int(0.52 * 100) = 52

# X: индекс в окне → индекс в полном DataFrame
actual_idx = 400 + 52 = 452

# Y: нормализованная координата → цена
price = 290.0 + 0.31 * (300.0 - 290.0) = 293.1

# Результат: T0 находится на свече с индексом 452, цена 293.1
```

---

## Почему так сделано?

### Проблема: Прямое предсказание индекса

Если бы нейросеть предсказывала индекс напрямую:
- ❌ Нужно знать, сколько свечей в графике
- ❌ Разные графики → разные диапазоны индексов
- ❌ Модель должна подстраиваться под размер графика
- ❌ Сложнее обобщать на разных инструментах

### Решение: Нормализованные координаты

Предсказание нормализованных координат (0-1):
- ✅ Универсально — работает для любых размеров графиков
- ✅ Обобщение — модель работает с относительными позициями
- ✅ Не зависит от количества свечей
- ✅ Легко преобразовать обратно в реальные координаты

---

## Пример работы на реальных данных

### Сценарий: Анализ графика VKCO

```python
# 1. Загружаем реальные данные
df = scanner.get_candles_df('VKCO', 'TQBR', days_back=60, interval='1h')
# df содержит 724 свечи (индексы 0-723)

# 2. Берем окно для анализа
window_size = 100
df_plot = df.tail(window_size).copy()  # Последние 100 свечей (idx 624-723)
window_start = 624

# 3. Преобразуем в изображение
image, normalization_params = dataset._candles_to_image(df_plot)
# normalization_params: {'price_min': 288.0, 'price_max': 296.0, 'window_start': 624}

# 4. Нейросеть предсказывает
pred_keypoints = model(image)  # [5, 2] - нормализованные координаты
# Пример предсказания:
# T0: [0.15, 0.30]  → x_norm=0.15, y_norm=0.30
# T1: [0.25, 0.85]  → x_norm=0.25, y_norm=0.85
# T2: [0.45, 0.40]  → x_norm=0.45, y_norm=0.40
# T3: [0.75, 0.90]  → x_norm=0.75, y_norm=0.90
# T4: [0.85, 0.50]  → x_norm=0.85, y_norm=0.50

# 5. Обратное преобразование
for i, (x_norm, y_norm) in enumerate(pred_keypoints):
    # X: нормализованная → индекс в окне
    idx_in_window = int(x_norm * 100)  # 0-99
    # X: индекс в окне → реальный индекс
    real_idx = 624 + idx_in_window
    
    # Y: нормализованная → цена
    price = 288.0 + y_norm * (296.0 - 288.0)

# Результат:
# T0: idx=639 (624 + 15), price=290.4
# T1: idx=649 (624 + 25), price=294.8
# T2: idx=669 (624 + 45), price=291.2
# T3: idx=699 (624 + 75), price=295.2
# T4: idx=709 (624 + 85), price=292.0
```

---

## Ключевые моменты

1. **При обучении:**
   - Индекс свечи → нормализованная координата X (0-1)
   - Модель учится предсказывать нормализованные координаты

2. **При предсказании:**
   - Модель предсказывает нормализованные координаты (0-1)
   - Обратное преобразование: нормализованные → реальный индекс

3. **Преимущества:**
   - ✅ Универсальность — работает с любыми графиками
   - ✅ Обобщение — модель работает с относительными позициями
   - ✅ Не зависит от размера графика

4. **Важно:**
   - Нужно знать параметры нормализации (price_min, price_max, window_start)
   - Обратное преобразование должно использовать те же параметры, что и при создании изображения

---

## Итог

**Нейросеть НЕ предсказывает индекс напрямую!**

Вместо этого:
1. ✅ Модель предсказывает **нормализованные координаты** (0-1)
2. ✅ Мы преобразуем их обратно в **индексы свечей** при визуализации
3. ✅ Это позволяет модели работать с любыми графиками любого размера

**Процесс:**
```
Обучение:    idx → x_norm (0-1) → модель учится
Предсказание: модель → x_norm (0-1) → обратное преобразование → idx
```

Подробности в коде:
- `data_loader_keypoints.py` - преобразование idx → нормализованные (обучение)
- `predict_keypoints.py` - обратное преобразование (предсказание)

