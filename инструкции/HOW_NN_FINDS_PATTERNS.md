# Логика поиска паттернов нейронной сетью

## Общая схема работы

Нейронная сеть использует **sliding window** (скользящее окно) для анализа всего графика и поиска паттернов "Флаг" с детекцией ключевых точек T0-T4.

## Этап 1: Преобразование свечей в изображение

### 1.1. Выбор окна данных
```
Исходный график: [свеча1, свеча2, ..., свечаN]
Окно (window=100): берем 100 последовательных свечей
```

**Код:** `data_loader_keypoints.py::_candles_to_image()`

- Если данных больше `window`, берем последние `window` свечей
- Если данных меньше `window`, используем все доступные свечи
- Сохраняем `window_start` - индекс начала окна в исходном DataFrame

### 1.2. Нормализация цен
```python
price_min = min(low всех свечей в окне)
price_max = max(high всех свечей в окне)
price_range = price_max - price_min

# Нормализуем все цены к диапазону [0, 1]
normalized_price = (price - price_min) / price_range
```

**Зачем:** Приводим все цены к единому масштабу независимо от абсолютных значений (например, 100₽ или 10000₽).

### 1.3. Создание изображения графика
**Код:** `data_loader_keypoints.py::_candles_to_image()`

1. **Создаем фигуру matplotlib:**
   - Размер: 224x224 пикселя (стандартный размер для CNN)
   - Фон: черный
   - Без осей и подписей

2. **Рисуем свечи:**
   - Для каждой свечи в окне:
     - **Тело свечи:** прямоугольник от `open` до `close`
       - Зеленый, если `close >= open` (бычья свеча)
       - Красный, если `close < open` (медвежья свеча)
     - **Тени:** линии от `low` до `high`

3. **Конвертация в тензор:**
   - PIL Image → numpy array → torch tensor
   - Формат: `(3, 224, 224)` - 3 канала RGB, высота, ширина
   - Значения нормализованы к [0, 1]

**Результат:** Изображение графика свечей размером 224x224 пикселя

## Этап 2: Sliding Window - анализ всего графика

### 2.1. Принцип работы
**Код:** `predict_keypoints.py::predict_with_sliding_window()`

```
График: [свеча0, свеча1, ..., свеча999]
Window = 100, Step = 10

Окно 1: [свеча0-свеча99]     → анализ
Окно 2: [свеча10-свеча109]   → анализ
Окно 3: [свеча20-свеча119]   → анализ
...
Окно N: [свеча900-свеча999]  → анализ
```

**Параметры:**
- `window` (по умолчанию 100) - размер окна (количество свечей)
- `step` (по умолчанию 10) - шаг сдвига окна
- Чем меньше `step`, тем больше перекрытие окон и больше паттернов будет найдено

### 2.2. Обработка каждого окна
Для каждого окна:
1. Извлекаем подмножество свечей: `df_window = df.iloc[start_idx:end_idx]`
2. Преобразуем в изображение (см. Этап 1)
3. Подаем в нейросеть
4. Получаем предсказания

## Этап 3: Архитектура нейронной сети

### 3.1. Структура модели
**Код:** `model_keypoints.py::FlagPatternKeypointCNN`

```
Вход: Изображение (3, 224, 224)
  ↓
CNN Backbone (общие признаки):
  - Conv1: 3 → 32 каналов
  - Conv2: 32 → 32 каналов
  - Pool1: уменьшение в 2 раза (224 → 112)
  - Conv3: 32 → 64 каналов
  - Conv4: 64 → 64 каналов
  - Pool2: уменьшение в 2 раза (112 → 56)
  - Conv5: 64 → 128 каналов
  - Conv6: 128 → 128 каналов
  - Pool3: уменьшение в 2 раза (56 → 28)
  - Conv7: 128 → 256 каналов
  - Conv8: 256 → 256 каналов
  - Pool4: уменьшение в 2 раза (28 → 14)
  ↓
Общие признаки (512 нейронов)
  ↓
    ├─→ Ветка классификации → [3 класса]
    │     - 0: нет паттерна
    │     - 1: бычий флаг (LONG)
    │     - 2: медвежий флаг (SHORT)
    │
    └─→ Ветка регрессии → [5 точек × 2 координаты]
          - T0: (x, y)
          - T1: (x, y)
          - T2: (x, y)
          - T3: (x, y)
          - T4: (x, y)
```

### 3.2. Два выхода модели

**1. Классификация (class_logits):**
- Размер: `[batch_size, 3]`
- Значения: логиты (сырые вероятности до softmax)
- После softmax: вероятности для каждого класса

**2. Регрессия ключевых точек (keypoints):**
- Размер: `[batch_size, 5, 2]`
- Координаты нормализованы к [0, 1]:
  - `x` ∈ [0, 1] - позиция по горизонтали (время)
  - `y` ∈ [0, 1] - позиция по вертикали (цена)

## Этап 4: Обработка предсказаний

### 4.1. Фильтрация по уверенности
**Код:** `predict_keypoints.py::predict_with_sliding_window()`

```python
predicted_class = argmax(probabilities)  # Класс с максимальной вероятностью
pred_prob = probabilities[predicted_class]  # Вероятность этого класса

if predicted_class > 0 and pred_prob >= min_confidence:
    # Это паттерн (бычий или медвежий) с достаточной уверенностью
    # Обрабатываем дальше
```

**Параметры:**
- `min_confidence` (по умолчанию 0.7) - минимальная вероятность для принятия паттерна
- Если вероятность ниже порога, паттерн игнорируется

### 4.2. Преобразование нормализованных координат в реальные

**Для координаты X (время/индекс свечи):**
```python
# Нормализованная координата x_norm ∈ [0, 1]
# где 0 = первая свеча в окне, 1 = последняя свеча в окне

candle_idx_in_window = x_norm * (window_size - 1)
candle_idx_in_window = round(candle_idx_in_window)
candle_idx_in_window = clamp(0, window_size - 1)

# Корректируем относительно исходного DataFrame
actual_idx = window_start + candle_idx_in_window
```

**Для координаты Y (цена):**
```python
# Нормализованная координата y_norm ∈ [0, 1]
# где 0 = минимальная цена в окне, 1 = максимальная цена в окне

price = price_min + y_norm * price_range
# price_range = price_max - price_min

# Ограничиваем цену диапазоном свечи для точности
candle_row = df_window.iloc[candle_idx_in_window]
price = clamp(candle_row['low'], candle_row['high'], price)
```

### 4.3. Формирование результата
```python
prediction = {
    'window_start': start_idx,      # Начало окна в исходном DataFrame
    'window_end': end_idx,           # Конец окна
    'class': predicted_class,        # 1 (бычий) или 2 (медвежий)
    'probability': pred_prob,        # Вероятность (0.0 - 1.0)
    'points': [                      # Массив из 5 точек
        {'name': 'T0', 'idx': ..., 'price': ...},
        {'name': 'T1', 'idx': ..., 'price': ...},
        {'name': 'T2', 'idx': ..., 'price': ...},
        {'name': 'T3', 'idx': ..., 'price': ...},
        {'name': 'T4', 'idx': ..., 'price': ...}
    ]
}
```

## Этап 5: Визуализация и подтверждение

### 5.1. Отображение на графике
- Все найденные паттерны отображаются на графике
- Каждый паттерн имеет:
  - 5 точек (T0-T4) с цветными маркерами
  - Линии: T0-T1 (флагшток), T1-T3, T2-T4
  - Цвет и стиль зависят от статуса (подтвержден/отклонен/ожидает)

### 5.2. Подтверждение/отклонение пользователем
- Пользователь просматривает каждый паттерн
- Нажимает "✅ Подтвердить" или "❌ Отклонить"
- Подтвержденные паттерны сохраняются как положительные примеры (label=1 или 2)
- Отклоненные паттерны сохраняются как отрицательные примеры (label=0)

## Ключевые особенности

### 1. Нормализация координат
- Все координаты нормализуются к [0, 1] для обучения
- При предсказании координаты денормализуются обратно
- Это позволяет модели работать с любыми ценами и таймфреймами

### 2. Sliding Window
- Позволяет анализировать графики любой длины
- Перекрытие окон (step < window) обеспечивает поиск паттернов на границах окон
- Чем меньше step, тем больше паттернов будет найдено (но медленнее)

### 3. Мультизадачность
- Модель одновременно решает две задачи:
  - **Классификация:** есть ли паттерн и какой тип
  - **Регрессия:** где находятся ключевые точки
- Общие признаки извлекаются один раз, затем используются для обеих задач

### 4. Обработка разных размеров окон
- Если данных меньше window, используется весь доступный период
- Нормализация координат учитывает реальный размер окна
- Это позволяет работать с короткими и длинными графиками

## Параметры настройки

### В дашборде:
- **Размер окна (window):** 50-200 свечей (по умолчанию 100)
  - Больше окно = больше контекста, но может пропустить короткие паттерны
  - Меньше окно = лучше для коротких паттернов, но меньше контекста

- **Шаг окна (step):** 5-50 свечей (по умолчанию 10)
  - Меньше шаг = больше перекрытие, больше паттернов, медленнее
  - Больше шаг = быстрее, но может пропустить паттерны на границах

- **Минимальная уверенность (min_confidence):** 0.0-1.0 (по умолчанию 0.6)
  - Выше порог = только уверенные паттерны, меньше ложных срабатываний
  - Ниже порог = больше паттернов, но больше ложных срабатываний

## Пример работы

```
Исходный график: 500 свечей
Window = 100, Step = 10

Окно 1 (0-99):
  → Преобразование в изображение 224x224
  → Нейросеть: class=1 (бычий), prob=0.85
  → Keypoints: T0(0.1, 0.2), T1(0.3, 0.8), T2(0.5, 0.3), T3(0.7, 0.7), T4(0.9, 0.4)
  → Денормализация: T0(idx=10, price=100.5), T1(idx=30, price=105.2), ...
  → ✅ Паттерн найден!

Окно 2 (10-109):
  → Анализ...
  → class=0 (нет паттерна), prob=0.95
  → ❌ Пропускаем

Окно 3 (20-119):
  → Анализ...
  → class=2 (медвежий), prob=0.72
  → ✅ Паттерн найден!

...

Итого: найдено 15 паттернов из 41 окна
```

## Преимущества подхода

1. **Автоматизация:** Не нужно вручную искать паттерны
2. **Масштабируемость:** Может анализировать графики любой длины
3. **Точность:** Находит ключевые точки с высокой точностью
4. **Гибкость:** Работает с разными таймфреймами и инструментами
5. **Обучаемость:** Модель улучшается с добавлением размеченных данных

## Ограничения

1. **Зависимость от качества обучения:** Модель работает только на том, чему была обучена
2. **Вычислительная сложность:** Sliding window требует много вычислений для больших графиков
3. **Параметры окна:** Неправильный выбор window/step может пропустить паттерны
4. **Ложные срабатывания:** Модель может находить паттерны там, где их нет (требуется проверка)
