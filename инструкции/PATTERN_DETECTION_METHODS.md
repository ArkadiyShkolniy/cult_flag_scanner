# Способы поиска паттернов на финансовых графиках

## Обзор методов

Существует множество подходов к поиску паттернов на финансовых графиках. Каждый метод имеет свои преимущества и ограничения.

---

## 1. Математический/Правило-ориентированный подход (Rule-Based)

### Описание
Поиск паттернов на основе четко определенных математических правил и геометрических ограничений.

### Как работает
1. **Определение экстремумов:**
   - Поиск локальных максимумов (high) и минимумов (low)
   - Фильтрация по значимости (минимальная разница в цене)

2. **Проверка геометрических условий:**
   - Проверка соотношений цен между точками (Fibonacci уровни)
   - Проверка углов и наклонов линий тренда
   - Проверка параллельности/сходимости линий

3. **Валидация паттерна:**
   - Проверка всех правил для конкретного паттерна
   - Фильтрация по дополнительным условиям (объем, время формирования)

### Пример из проекта
**Файл:** `scanners/bullish_flag_scanner.py`, `scanners/bearish_flag_scanner.py`

```python
# Поиск точек T0-T4 с проверкой:
# - T2 >= 0.62 * (T0-T1) для LONG
# - T3 в диапазоне 0.5 * (T1-T2)
# - T4 в диапазоне 0.5 * (T2-T3)
# - Линии T1-T3 и T2-T4 не расходятся
# - Линии не пересекают свечи
```

### Преимущества
✅ **Точность:** Четкие правила, легко понять логику  
✅ **Интерпретируемость:** Можно объяснить, почему паттерн найден  
✅ **Быстрота:** Не требует обучения, работает сразу  
✅ **Надежность:** Не зависит от качества данных обучения  
✅ **Контролируемость:** Легко настроить параметры  

### Недостатки
❌ **Жесткость:** Строгие правила могут пропустить валидные паттерны  
❌ **Сложность правил:** Для сложных паттернов правила становятся очень сложными  
❌ **Ручная настройка:** Требуется экспертиза для определения правил  

### Когда использовать
- Когда нужна высокая точность и контроль
- Когда паттерн имеет четкие геометрические характеристики
- Когда важна интерпретируемость результатов

---

## 2. Нейронные сети (Deep Learning)

### Описание
Использование глубоких нейронных сетей для распознавания паттернов на изображениях графиков.

### Как работает
1. **Преобразование в изображение:**
   - Свечи → изображение графика (224x224 пикселя)
   - Нормализация цен к [0, 1]

2. **Обучение CNN:**
   - Сверточные слои извлекают признаки
   - Мультизадачность: классификация + регрессия координат

3. **Sliding Window:**
   - Анализ всего графика окнами
   - Поиск паттернов в каждом окне

### Пример из проекта
**Файл:** `neural_network/predict_keypoints.py`, `neural_network/model_keypoints.py`

```python
# CNN архитектура:
# - Вход: изображение (3, 224, 224)
# - Выход 1: класс (нет/бычий/медвежий)
# - Выход 2: координаты точек T0-T4
```

### Преимущества
✅ **Гибкость:** Может находить сложные паттерны  
✅ **Автоматизация:** Не требует ручного описания правил  
✅ **Адаптивность:** Может улучшаться с новыми данными  
✅ **Устойчивость к шуму:** Может работать с неидеальными данными  

### Недостатки
❌ **Требует обучения:** Нужны размеченные данные  
❌ **Черный ящик:** Сложно понять, почему паттерн найден  
❌ **Вычислительная сложность:** Требует GPU для быстрой работы  
❌ **Зависимость от данных:** Качество зависит от обучающей выборки  

### Когда использовать
- Когда есть много размеченных данных
- Когда паттерн сложно описать правилами
- Когда нужна автоматизация процесса

---

## 3. Гибридный подход (Hybrid)

### Описание
Комбинация математического сканера и нейронной сети для повышения точности.

### Как работает
1. **Первичный поиск:**
   - Математический сканер находит кандидатов
   - Нейросеть проверяет кандидатов

2. **Валидация:**
   - Оба метода должны согласиться
   - Или один метод подтверждает результат другого

### Пример из проекта
**Файл:** `scanners/hybrid_scanner.py`

```python
# 1. Математический сканер находит кандидатов
# 2. Нейросеть проверяет каждый кандидат
# 3. Результат: только паттерны, подтвержденные обоими методами
```

### Преимущества
✅ **Высокая точность:** Двойная проверка снижает ложные срабатывания  
✅ **Баланс:** Сочетает преимущества обоих методов  
✅ **Надежность:** Если один метод ошибается, второй может исправить  

### Недостатки
❌ **Сложность:** Требует реализации обоих методов  
❌ **Медленнее:** Два прохода вместо одного  

### Когда использовать
- Когда нужна максимальная точность
- Когда есть ресурсы для обоих методов
- В продакшене, где важна надежность

---

## 4. Технические индикаторы

### Описание
Использование технических индикаторов для поиска паттернов.

### Как работает
1. **Расчет индикаторов:**
   - Moving Averages (MA, EMA)
   - RSI, MACD, Bollinger Bands
   - Volume indicators

2. **Поиск сигналов:**
   - Пересечения линий
   - Дивергенции
   - Формирование паттернов на индикаторах

### Примеры
```python
# Поиск паттерна "Флаг" через индикаторы:
# 1. EMA(20) > EMA(50) - восходящий тренд
# 2. RSI < 70 - не перекуплен
# 3. Объем уменьшается в консолидации
# 4. Цена откатывается к EMA(20)
```

### Преимущества
✅ **Простота:** Легко реализовать  
✅ **Стандартность:** Широко используемые методы  
✅ **Быстрота:** Быстрые вычисления  

### Недостатки
❌ **Запаздывание:** Индикаторы отстают от цены  
❌ **Ложные сигналы:** Много ложных срабатываний  
❌ **Не специфичны:** Не ищут конкретные паттерны  

### Когда использовать
- Для фильтрации паттернов
- В комбинации с другими методами
- Для подтверждения сигналов

---

## 5. Статистические методы

### Описание
Использование статистических методов для поиска паттернов.

### Как работает
1. **Корреляционный анализ:**
   - Поиск похожих участков графика
   - Сравнение с историческими паттернами

2. **Кластеризация:**
   - Группировка похожих паттернов
   - Выделение типичных форм

3. **Временные ряды:**
   - ARIMA, GARCH модели
   - Поиск аномалий и паттернов

### Примеры
```python
# 1. Корреляция с эталонным паттерном
correlation = np.corrcoef(pattern, template)

# 2. K-means кластеризация паттернов
from sklearn.cluster import KMeans
clusters = KMeans(n_clusters=5).fit(patterns)

# 3. Поиск похожих участков
similarity = cosine_similarity(pattern, historical_patterns)
```

### Преимущества
✅ **Объективность:** Основаны на математике  
✅ **Гибкость:** Можно адаптировать под разные паттерны  
✅ **Анализ:** Позволяют анализировать структуру данных  

### Недостатки
❌ **Сложность:** Требуют понимания статистики  
❌ **Вычислительная сложность:** Могут быть медленными  
❌ **Не специфичны:** Не всегда подходят для конкретных паттернов  

### Когда использовать
- Для анализа больших объемов данных
- Для поиска скрытых закономерностей
- В исследовательских целях

---

## 6. Генетические алгоритмы

### Описание
Использование эволюционных алгоритмов для поиска оптимальных правил.

### Как работает
1. **Инициализация популяции:**
   - Создание набора правил (хромосом)
   - Каждое правило - набор параметров

2. **Оценка приспособленности:**
   - Тестирование правил на исторических данных
   - Оценка точности и прибыльности

3. **Эволюция:**
   - Отбор лучших правил
   - Скрещивание и мутация
   - Повторение до сходимости

### Примеры
```python
# Хромосома = набор параметров:
# [min_pole_height, max_retracement, min_consolidation_days, ...]

# Фитнес функция:
fitness = accuracy * profit_factor - false_positives
```

### Преимущества
✅ **Автоматический поиск:** Находит оптимальные параметры  
✅ **Адаптивность:** Может адаптироваться к рынку  
✅ **Гибкость:** Может найти неочевидные правила  

### Недостатки
❌ **Медленность:** Требует много вычислений  
❌ **Сложность:** Сложно настроить  
❌ **Переобучение:** Может переобучиться на исторических данных  

### Когда использовать
- Для оптимизации параметров правил
- Когда нужно найти неочевидные закономерности
- В исследовательских целях

---

## 7. Графовые методы

### Описание
Представление графика как графа и поиск паттернов через анализ структуры графа.

### Как работает
1. **Построение графа:**
   - Узлы = экстремумы (high/low)
   - Ребра = связи между экстремумами

2. **Поиск подграфов:**
   - Поиск изоморфных подграфов
   - Сопоставление с шаблонами паттернов

3. **Валидация:**
   - Проверка геометрических условий
   - Фильтрация по дополнительным критериям

### Примеры
```python
# Граф паттерна "Флаг":
# T0 --(up)--> T1 --(down)--> T2 --(up)--> T3 --(down)--> T4
# Поиск изоморфных подграфов в графе графика
```

### Преимущества
✅ **Структурный анализ:** Анализирует структуру паттерна  
✅ **Гибкость:** Может находить вариации паттернов  
✅ **Теоретическая база:** Основан на теории графов  

### Недостатки
❌ **Сложность:** Требует построения графа  
❌ **Вычислительная сложность:** Поиск изоморфизма NP-сложен  
❌ **Не распространен:** Мало готовых реализаций  

### Когда использовать
- Для сложных структурных паттернов
- В исследовательских целях
- Когда нужен структурный анализ

---

## 8. Символьная регрессия

### Описание
Автоматическое построение математических формул для описания паттернов.

### Как работает
1. **Генерация формул:**
   - Использование генетического программирования
   - Построение деревьев выражений

2. **Оценка формул:**
   - Тестирование на исторических данных
   - Оценка точности

3. **Оптимизация:**
   - Эволюция формул
   - Упрощение и оптимизация

### Примеры
```python
# Автоматически найденная формула:
pattern = (high[0] - low[0]) > 0.05 * price[0] and
          (high[5] - low[5]) < 0.02 * price[5] and
          (high[10] - low[10]) > 0.05 * price[10]
```

### Преимущества
✅ **Автоматизация:** Находит формулы автоматически  
✅ **Интерпретируемость:** Формулы понятны  
✅ **Гибкость:** Может найти неочевидные закономерности  

### Недостатки
❌ **Медленность:** Очень медленные вычисления  
❌ **Сложность:** Требует специальных библиотек  
❌ **Переобучение:** Может создать слишком сложные формулы  

### Когда использовать
- Для исследования новых паттернов
- Когда нужны интерпретируемые правила
- В академических целях

---

## 9. Временные шаблоны (Template Matching)

### Описание
Сопоставление участков графика с эталонными шаблонами паттернов.

### Как работает
1. **Создание шаблонов:**
   - Нормализация эталонных паттернов
   - Сохранение как шаблоны

2. **Скользящее окно:**
   - Нормализация каждого окна
   - Сравнение с шаблонами

3. **Метрика схожести:**
   - Корреляция, DTW (Dynamic Time Warping)
   - Евклидово расстояние

### Примеры
```python
# DTW для сравнения временных рядов
from dtw import dtw
distance = dtw(pattern, template).distance

# Корреляция
correlation = np.corrcoef(pattern, template)[0, 1]
```

### Преимущества
✅ **Простота:** Легко понять и реализовать  
✅ **Гибкость:** Можно использовать разные метрики  
✅ **Интерпретируемость:** Понятно, что ищется  

### Недостатки
❌ **Чувствительность к масштабу:** Требует нормализации  
❌ **Вычислительная сложность:** DTW медленный  
❌ **Зависимость от шаблонов:** Качество зависит от эталонов  

### Когда использовать
- Когда есть хорошие эталонные паттерны
- Для поиска похожих участков
- В комбинации с другими методами

---

## 10. Ансамбли методов (Ensemble)

### Описание
Комбинация нескольких методов для повышения точности.

### Как работает
1. **Несколько методов:**
   - Математический сканер
   - Нейросеть
   - Индикаторы
   - Статистика

2. **Голосование:**
   - Каждый метод дает свой ответ
   - Итоговое решение = большинство голосов
   - Или взвешенное голосование

3. **Мета-обучение:**
   - Модель учится комбинировать результаты
   - Оптимизация весов методов

### Примеры
```python
# Голосование:
methods = [math_scanner, neural_network, indicators]
votes = [m.predict(pattern) for m in methods]
final_decision = majority_vote(votes)

# Взвешенное голосование:
weights = [0.4, 0.4, 0.2]  # Веса методов
final_decision = weighted_vote(votes, weights)
```

### Преимущества
✅ **Высокая точность:** Комбинация методов повышает точность  
✅ **Устойчивость:** Если один метод ошибается, другие исправляют  
✅ **Гибкость:** Можно комбинировать любые методы  

### Недостатки
❌ **Сложность:** Требует реализации нескольких методов  
❌ **Медленность:** Все методы должны работать  
❌ **Настройка:** Нужно оптимизировать веса  

### Когда использовать
- В продакшене, где важна надежность
- Когда есть ресурсы для нескольких методов
- Для максимальной точности

---

## Сравнительная таблица методов

| Метод | Точность | Скорость | Интерпретируемость | Сложность реализации | Требует обучения |
|-------|----------|----------|-------------------|---------------------|------------------|
| Математический | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | ❌ |
| Нейросети | ⭐⭐⭐⭐ | ⭐⭐ | ⭐ | ⭐⭐⭐⭐ | ✅ |
| Гибридный | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐ | ✅ |
| Индикаторы | ⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐ | ❌ |
| Статистика | ⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐ | ❌ |
| Генетические | ⭐⭐⭐ | ⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐ | ❌ |
| Графовые | ⭐⭐⭐ | ⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐ | ❌ |
| Символьная регрессия | ⭐⭐ | ⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ❌ |
| Template Matching | ⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐ | ❌ |
| Ансамбли | ⭐⭐⭐⭐⭐ | ⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ✅ |

---

## Рекомендации по выбору метода

### Для продакшена:
1. **Гибридный подход** - максимальная надежность
2. **Математический сканер** - если нужна скорость и контроль
3. **Ансамбли** - если есть ресурсы

### Для исследований:
1. **Нейросети** - для изучения сложных паттернов
2. **Статистика** - для анализа закономерностей
3. **Генетические алгоритмы** - для оптимизации параметров

### Для быстрого прототипирования:
1. **Template Matching** - простой и быстрый
2. **Индикаторы** - стандартные методы
3. **Математический сканер** - четкие правила

---

## Комбинация методов в проекте

В текущем проекте используются:

1. **Математический сканер** (`scanners/bullish_flag_scanner.py`, `bearish_flag_scanner.py`)
   - Основной метод поиска
   - Проверка геометрических правил

2. **Нейронная сеть** (`neural_network/predict_keypoints.py`)
   - Дополнительная валидация
   - Поиск паттернов в дашборде

3. **Гибридный подход** (`scanners/hybrid_scanner.py`)
   - Комбинация обоих методов
   - Повышение точности

---

## Заключение

Каждый метод имеет свои преимущества. Выбор зависит от:
- Требований к точности
- Доступных ресурсов
- Необходимости интерпретируемости
- Наличия размеченных данных

**Идеальный подход:** Комбинация нескольких методов для максимальной надежности и точности.
